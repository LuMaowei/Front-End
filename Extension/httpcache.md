# HTTP缓存学习笔记

缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。

### 缓存的优点
- 缓存减少了冗余的数据传输
- 缓存缓解了网络瓶颈的问题
- 缓存降低了对原始服务器的要求
- 缓存降低了短距离的时延

### 缓存的分类
缓存的种类大致可归为两类：
- 私有缓存：私有缓存只能用于单独用户。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。
- 共享缓存：是特殊的共享代理服务器，可以被多个用户使用。

### 缓存的处理步骤
对于一条HTTP GET报文的基本缓存处理过程：
1. 接收：缓存从网络中读取抵达的请求报文
2. 解析：缓存对报文进行解析，提取出URL和各种首部
3. 查询：缓存查看是否有本地副本可用，如果没有，就获取一份副本，并将其保存在本地
4. 新鲜度检测：缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新
5. 创建响应：缓存会用新的首部和已缓存的主体来构建一条响应报文
6. 发送：缓存通过网络将响应发回给客户端
7. 日志：缓存可选地创建一个日志文件条目来描述这个事务

### 缓存控制
HTTP/1.1定义的 `Cache-Control`头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。
- no-store：标识为`no-store`的响应会禁止缓存对响应进行复制。
- no-cache：标识为`no-cache`的响应实际上可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。
- must-revalidate：`must-revalidate`响应首部告诉缓存，在事先没有跟原始服务器进行再验证的情况下，不能提供这个对象的陈旧副本。缓存任然可以随意提供新鲜的副本。
####　1. 禁止进行缓存
缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。
```
Cache-Control: no-store
Cache-Control: no-cache, no-store, must-revalidate
```
#### 2. 强制确认缓存
每次有请求发出时，服务器端会验证请求中所描述的缓存是否过期，若未过期（返回304），则缓存才使用本地缓存副本。
```
Cache-Control: no-cache
```
#### 3. 缓存过期机制
max-age是距离请求发起的时间的秒数。
```
Cache-Control: max-age=31536000
```

### 新鲜度
一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。
- If-None-Match：当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个`If-None-Match`头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 `304`则表示此资源副本是新鲜的。
```
ETag: "v2.6"
If-None-Match: "v2.6"
```
- If-Modified-Since：If-Modified-Since再验证请求通常被称为IMS请求，只有自某个日期之后资源发生了变化的时候，IMS请求才会指示服务器执行请求。
```
If-Modified-Since: <cached last-modified date>
```

### 其他相关设置
#### 1. Last-Modified
服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。
```
Last-Modified: Fri, 23 Jul 2017 01:47:00 GMT
```
这个时候客户端在请求资源的时候需要发送一个字段来标记时间，服务器端会根据这个时间与服务器上该资源的最终修改时间对比，若一致，则说明该资源没有被修改过。  
客户端发送的这个字段一般有两种：
```
If-Modified-Since: Last-Modified-value
```
该字段告诉服务器如果客户端传来的最后修改时间和服务器上的一致，直接返回 304 状态码即可，当前各大浏览器均是使用该字段来向服务器传递保存的 Last-Modified 的值。如果时间不一致的话，服务器会返回所有的这个资源并返回 200 状态码。
```
If-Unmodified-Since: Last-Modified-value
```
该字段告诉服务器如果客户端传来的最后修改时间和服务器上的不一致，则直接返回 412 状态码(Precondition Failed)。

#### 2. ETag
`Last-Modified` 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。而`ETag`作为缓存的一种强校验器，如果资源请求的响应头里含有`ETag`, 客户端可以在后续的请求的头中带上 `If-None-Match`头来验证缓存。  
客户端发送的这个字段一般有两种：
```
If-None-Match: ETag-value
```
告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送304 和响应报头即可。
```
If-Match: ETag-value
```
该字段告诉服务器如果客户端传来的 Etag 值跟服务器上的不一致，则直接返回 412 状态码(Precondition Failed)。

#### 3. Pragma
是HTTP/1.0标准中定义的一个header属性，请求中包含`Pragma`的效果跟在头信息中定义`Cache-Control: no-cache`相同，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的`Cache-control`头。通常定义`Pragma`以向后兼容基于HTTP/1.0的客户端。

#### 4. Expires
`Expires` 可以用来设置缓存的时间，它的值是一个格林尼治时间，比如Mon, 20 Jul 2017 10:08:35 GMT 来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。

#### 5. Vary
`Vary` HTTP 响应头决定了对于后续的请求头。当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的`Vary`都匹配，才能使用缓存的响应。
```
Vary: User-Agent
```

#### 参考
- [HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)
- [浅谈浏览器http的缓存机制](http://www.cnblogs.com/vajoy/p/5341664.html)
- [HTTP缓存控制小结](http://imweb.io/topic/5795dcb6fb312541492eda8c)





 
