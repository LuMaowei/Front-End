# 正则表达式(基础篇)
- ### 啥是正则表达式？
  > 正则就是用有限的符号，表达无限的序列。

  记住一句重要的话，**正则表达式是匹配模式，要么匹配字符，要么匹配位置。**

- ### 精确匹配
  ``` javascript
  /abc/ // 匹配 abc
  /123/ // 匹配 123
  ```
  正则的强大在于它能实现模糊匹配。

- ### 模糊匹配：
  模糊匹配可分为：**横向匹配**和**纵向匹配**。
   #### 1. 横向模糊匹配：
   > 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。

   实现的方式是使用量词。譬如{m,n}，表示连续出现最少m次，最多n次。
   ``` javascript
   /ab{2,5}c/
   //表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”
   ```
   #### 2. 纵向模糊匹配
   > 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。

   实现的方式是使用字符组。
   ``` javascript
   /a[123]b/
   //可以匹配如下三种字符串："a1b"、"a2b"、"a3b"
   ```

- ### 字符组
   #### 1. 范围表示法
   如果字符组里的字符特别多的话，可以使用范围表示法。
   ``` javascript
   /[1-6a-fG-M]/
   //匹配[123456abcdefGHIJKLM]
   ```
   如果连字符有特殊用途，不能写成[a-z]，可以写成如下的方式：[-az]或[az-]或[a\-z]，总之不会让引擎认为是范围表示法就行了。
   #### 2. 排除字符组
   在纵向模糊匹配中可能还有的一种情况是，某位字符可以是任何字符，但就不能是"a"、"b"、"c"。这就是排除字符组（反义字符组）的概念。
   ``` javascript
   /[^abc]/
   //表示是一个除"a"、"b"、"c"之外的任意一个字符。
   ```
   字符组的第一位放^（脱字符），表示求反的概念。同样，它也有相应的范围表示法。
   #### 3. 常见的简写形式
   - \d： 等价于[0-9]，表示是一位数字。记忆方式：其英文是digit（数字）
   - \D： 等价于[^0-9]，表示除数字外的任意字符
   - \w： 等价于[0-9a-zA-Z_]，表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符
   - \W： 等价于[^0-9a-zA-Z_]，非单词字符
   - \s： 等价于[ \t\v\n\r\f]，表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母
   - \S： 等价于[^ \t\v\n\r\f]。 非空白符

- ### 量词
  量词也称重复。
  #### 1. 简写形式
  - {m,}  表示至少出现m次
  - {m}   等价于{m,m}，表示出现m次
  - ?     等价于{0,1}，表示出现或者不出现
  - \+    等价于{1,}，表示出现至少一次
  - \*     等价于{0,}，表示出现任意次，有可能不出现
  #### 2. 贪婪匹配
  ``` javascript
  /\d{2,5}/
  //表示数字连续出现2到5次，会匹配2位、3位、4位、5位连续数字
  ```
  其是贪婪的，它会尽可能多的匹配。反正只要在能力范围内，越多越好。但有时贪婪不是一件好事。
  #### 3. 惰性匹配
  ``` javascript
  /\d{2,5}?/
  //虽然2到5次都行，当2个就够的时候，就不在往下尝试了
  ```
  *通过在量词后面加个问号就能实现惰性匹配*

- ### 多选分支
  1.当一个模式可以实现横向和纵向模糊匹配，多选分支可以支持多个子模式任选其一。
  2.具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。
  ``` javascript
  /good|nice/
  //匹配"good"和"nice"
  ```
  但需要注意的是，*分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了*。
  比如用/good|goodbye/，去匹配"goodbye"字符串时，结果是：
  ``` javascript
  var regex = /good|goodbye/g;
  var string = "goodbye";
  console.log( string.match(regex) );
  // => ["good"]
  ```
  而把正则改成/goodbye|good/，结果是：
  ``` javascript
  var regex = /goodbye|good/g;
  var string = "goodbye";
  console.log( string.match(regex) );
  // => ["goodbye"]
  ```

- ### 案例分析
  #### 1. 匹配16进制颜色值
  形如：#FFF #Fbc01BD #eee
  ``` javascript
  var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;
  var string = "#FFF #Fbc01BD #eee";
  console.log( string.match(regex) );
  // => ["#FFF", "#Fbc01BD", "#eee"]
  ```
  #### 2. 匹配时间
  形如：23:29  06:06
  ``` javascript
  var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;
  ```
  #### 3. 匹配日期
  形如：2017-09-24
  ``` javascript
  var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
  ```
  #### 4. window操作系统文件路径
  形如：  
  F:\
  F:\study\javascript
  F:\study\javascript\regex\
  F:\study\javascript\regex\regular expression.pdf
  *注意：\ 字符需要转义*
  ``` javascript
  var regex = /^[a-zA-Z]:\\([^\\:*<>|"?\r\n/]+\\)*([^\\:*<>|"?\r\n/]+)?$/;
  ```
  #### 5. 匹配id
  形如：
  ``` javascript
  <div id="root" class="main"></div>
  ```
  使用惰性匹配：
  ``` javascript
  var regex = /id=".*?"/;
  ```
- ### 小结
  掌握字符组和量词就能解决大部分常见的情形，JavaScript正则算是入门了。
